use bincode::*;
use bit_vec::BitVec;
use rand::prelude::*;
use serde::{Deserialize, Serialize};
use std::net::SocketAddr;
use tokio::net::UdpSocket;
use tokio::prelude::*;
use tokio::runtime::current_thread::Runtime;
use url::Url;

//modules in the same crate
use crate::error::{Error, Result};
use crate::meta_info::TorrentInfo;
use crate::peer::Peer;
use crate::utils::random_string;

/*
 * This file contains all tracker related code.
 */

//static BIND_ADDR: &'static str = "127.0.0.1:11993";
static BIND_ADDR: &'static str = "0.0.0.0:0";
static CONSTANT_CLIENT_ID: &'static str = "-OT0001-";

#[derive(Serialize, Debug)]
struct ConnectRequest {
    connection_id: u64,
    action: u32,
    transaction_id: u32,
}

#[derive(Deserialize, Debug)]
struct ConnectResponse {
    action: u32,
    transaction_id: u32,
    connection_id: u64,
}

#[derive(Serialize, Debug)]
struct AnnounceRequest {
    connection_id: u64, //connection id: generated by tracker and it will send this field to the client in connection response.
    action: u32,        //action id: 1 for announce
    transaction_id: u32, //transaction id: randomaly
    info_hash: [u8; 20], //this is sha-1 hash of info section in torrent file.
    peer_id: [u8; 20],  //peer id
    downloaded: u64,
    left: u64,
    uploaded: u64,
    event: u32,
    ip_address: u32,
    key: u32,
    num_want: i32,
    port: u32, //we will listen on 11993
}

#[derive(Deserialize, Debug)]
struct IpAddr {
    ip: u32,
    port: u16,
}

#[derive(Deserialize, Debug)]
struct AnnounceResponse {
    action: u32,
    transaction_id: u32,
    interval: u32,
    leechers: u32,
    seeders: u32,
}

pub struct Tracker {
    socket: UdpSocket,
    connection_id: Option<u64>, //It is not always here
    peer_id: [u8; 20],
    hash_info: [u8; 20],
    downloaded: u64,
    uploaded: u64,
    left: u64,
    seeder: u32,
    leecher: u32,
    interval: u32,
    peers: Vec<String>, //    downloaded: u64,
                        //    left: u64,
                        //    peer_info: BitVec, //My information
}

impl Tracker {
    ///@param: meta_info MetaInfo struct of this torrent.
    pub async fn from_metainfo(meta_info: &TorrentInfo) -> Result<Self> {
        let announce_url = meta_info.get_announce();
        let base_url = Url::parse(&announce_url)?;
        let socket_addrs = base_url.socket_addrs(|| None)?;

        let socket = UdpSocket::bind(&BIND_ADDR.parse::<SocketAddr>()?).await?;
        //FIX ME: It should accept an array of address as std UDP
        let dummy: SocketAddr = "188.241.58.209:6969".parse()?;
        socket.connect(&dummy).await?;

        //Create a peer_id:
        //Firstly I generate 20 random byte, then replace first 8 bytes with -OT0001- (Oni torrent
        //version 0.01)
        let mut peer_id: [u8; 20] = Default::default();
        let mut random_id = random_string(12);
        random_id.insert_str(0, CONSTANT_CLIENT_ID);
        let random_id = random_id.as_bytes();
        peer_id.copy_from_slice(&random_id[0..]);

        Ok(Self {
            socket,
            connection_id: None,
            peer_id,
            hash_info: meta_info.get_info_hash(),
            downloaded: 0,
            uploaded: 0,
            left: 0,
            leecher: 0,
            seeder: 0,
            interval: 0,
            peers: Vec::new(),
        })
    }

    pub async fn connect(&mut self) -> Result<()> {
        //create a connect message and send it to tracker
        let mut rng = rand::thread_rng();
        let request_pkt = ConnectRequest {
            transaction_id: rng.gen(),
            connection_id: 0x41727101980,
            action: 0x0, //connect
        };

        let encoded_pkt: Vec<u8> = bincode::config().big_endian().serialize(&request_pkt)?;
        println!("Sending request");
        self.socket.send(&encoded_pkt).await?;

        let data_size = std::mem::size_of::<ConnectResponse>();
        let mut data = vec![0u8; data_size];
        let len = self.socket.recv(&mut data).await?;
        let decoded_pkt: ConnectResponse = bincode::config().big_endian().deserialize(&data)?;
        println!("Connect response: {:?}", &decoded_pkt);
        //Finish connect, save connection_id for later using
        self.connection_id = Some(decoded_pkt.connection_id);
        Ok(())
    }
    /// Function send request to tracker to get a list of swarms.
    /// @param num_want: Number of peers that client want to receive from tracker (use -1 for
    /// default)
    /// @event: Can leave empty (0) or it need to be started, stopped, or completed
    pub async fn annouce_request(&mut self, num_want: i32, event: u32) -> Result<()> {
        let mut rng = rand::thread_rng();
        let announce_request = AnnounceRequest {
            connection_id: self.connection_id.unwrap(),
            action: 1,
            transaction_id: rng.gen(),
            info_hash: self.hash_info,
            peer_id: self.peer_id,
            downloaded: self.downloaded,
            uploaded: self.uploaded,
            left: self.left,
            event,
            ip_address: 0,
            key: rng.gen(),
            num_want,
            port: 6881,
        };

        let encoded_pkt: Vec<u8> = bincode::config()
            .big_endian()
            .serialize(&announce_request)?;
        println!("Sending announce request");
        self.socket.send(&encoded_pkt).await?;
        //Testing only
        let mut data = vec![0u8; 1024];
        let len = self.socket.recv(&mut data).await?;
        let decoded_pkt: AnnounceResponse =
            bincode::config().big_endian().deserialize(&data[..20])?;
        println!("The interval: {}", decoded_pkt.interval);
        let mut pos = 20;

        //Separate
        let peer_id = self.peer_id;
        let hash_info = self.hash_info;
        loop {
            if pos >= len {
                break;
            }

            let mut ip_addr = [0u8; 4];
            let mut port_addr = [0u8; 2];
            ip_addr.copy_from_slice(&data[pos..pos + 4]);
            pos += 4;
            port_addr.copy_from_slice(&data[pos..pos + 2]);
            pos += 2;
            let ip_str = ip_addr
                .to_vec()
                .iter()
                .enumerate()
                .map(|(idx, val)| {
                    if idx < 3 {
                        format!("{}.", val)
                    } else {
                        format!("{}", val)
                    }
                })
                .collect::<String>();
            tokio::spawn(async move {
                let ip_addr = format!("{}:{}", ip_str, u16::from_be_bytes(port_addr));
                let mut peer = Peer::new(&ip_addr);
                peer.send_handshake(peer_id, hash_info).await;
            });
        }
        Ok(())
    }
}
